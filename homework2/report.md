# 41343131

作業二

## 解題說明

題目分別要求實現 `Polynomial`多項式類，以及C++方法來輸入及輸出多項式。並多載<<和>>運算子。

先觀察，可以注意到題目提供的多項是類資料結構有一個 `termArray` ，類型為 `Term` 的指標，還配有一個 `capacity` 用於存放 `termArray` 的大小，至於 `terms` 暫時不確定用途。題目描述(圖片)包含多項式的結構，以及建構子、`Add`、`Mult`及`Eval`方法。

在方法 `Add` 及 `Mult` 中，回傳類型為 `Polynomial` ，考量到有私有指標資料 `termArray` 因此應該需要複製建構子及=運算子多載進行指標資料複製。

在<<及>>運算子的實現中，需要決定字串輸入輸出格式，以及相對應分析算法。

一開始計畫每個多項式皆從 $x^0$ 也就是常數項開始，儘管其係數為0，犧牲部分空間以簡化算法。

原先打算做的方案退回，因為索引即指數在特定條件下造成嚴重浪費，故思考新方案(稀疏)。

稀疏方案加法沒甚麼問題，打算使用雙指針進行掃描(定義 `termArray` 皆為昇冪排列)相加放入暫存器(大小為 $n+m$ ，其中 $n$ 為多項式本身長度， $m$ 為加多項式之長度)。隨後從第一個開始分別針對this&that掃描，當相等直接相加；若其一較大則只處理小的，小的指針+1；若相加為零則最終暫存器長度-1(定義一開始與 $n+m$ 相等)。執行完畢後創建新的暫存器，過濾所有為零項。

相較於加法，乘法需要考慮中間結果項的合併與排序。直接相乘會產生 $m*n$ 個項，效率應列入考量。暫時列出以下三種方案:

1. 直接相乘定儲存於暫存器(大小為 $m*n$ )，隨後經排序後收縮成最終結果。
2. 針對key:value，先抓取最小與最大指數項，創建陣列最大-最小。依序暴力相乘 $n*m$ 將結果加入到結果陣列。
3. 直接相乘定儲存於暫存器(大小為 $m*n$ )，透過n個指針從開頭開始依序歷經累加後放入最終結果。

上述方案各有優缺

| 方案 | 時間複雜度 | 優點 | 缺點 |
| - | - | - | - |
| 方案一 | $O(m*n\log(mn))$ | 實現簡單 | 複雜度較高 |
| 方案二 | $O(m*n)$ | 實現簡單 | 有範圍限制且空間可能浪費 |
| 方案三 | $O(n^2*m)$ | 多線操作 | 僅透過n指針操作效率不足 |

因此我決定結合上述方案並改善方案三，透過二元堆積(最小堆)進行操作使複雜度降為 $O(n*m\log(n))$。

二元堆積法，透過一個陣列定義其為一樹狀結構使每當n項則左右項index分別為 $2n+1$ 及 $2n+2$

## 程式實作

## 效能分析

## 測試與驗證

## 效能量測

## 心得討論

## 申論及開發報告
